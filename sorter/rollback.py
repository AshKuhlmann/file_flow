from __future__ import annotations

import json
import pathlib
import shutil
from typing import Final

# Attempt to import the _sha256 function from the mover module within the same package.
# This is crucial for the strict mode's data integrity check.
try:
    from .mover import _sha256
except ImportError:
    # Provide a fallback for environments where mover might not be available,
    # though this will limit the functionality of the strict check.
    def _sha256(path: pathlib.Path) -> str:
        raise NotImplementedError("SHA256 calculation is unavailable.")

# Define a constant suffix for files that are moved out of the way during a rollback.
# This prevents data loss if a file already exists at the original source location.
_TRASH_SUFFIX: Final = ".__rollback_trash__"


def rollback(log_path: pathlib.Path, *, strict: bool = True) -> None:
    """
    Undoes file moves recorded in a JSONL log file (in last-in-first-out order).

    This function reads a log file generated by `move_with_log` and reverses
    each move operation, effectively restoring files to their original locations.

    Args:
        log_path: The path to the JSONL log file.
        strict: If True, verifies that the SHA256 checksum of the file at the
                destination matches the one in the log before moving it.
                This prevents moving a file that has been modified since the
                original operation.

    Raises:
        ValueError: In strict mode, if a file's checksum does not match the
                    one recorded in the log.
        FileNotFoundError: If the log file does not exist.
    """
    log_path = log_path.expanduser().resolve()
    if not log_path.exists():
        raise FileNotFoundError(f"Log file not found at: {log_path}")

    # Read all log entries from the JSONL file into a list.
    try:
        entries = [json.loads(line) for line in log_path.read_text().splitlines()]
    except (json.JSONDecodeError, UnicodeDecodeError) as e:
        print(f"Error reading or parsing log file {log_path}: {e}")
        return

    # Process entries in reverse order to undo operations chronologically (LIFO).
    for rec in reversed(entries):
        src = pathlib.Path(rec["src"])
        dst = pathlib.Path(rec["dst"])

        # If the destination file doesn't exist, there's nothing to roll back for this entry.
        if not dst.exists():
            print(f"Warning: Destination {dst} not found. Skipping rollback for this entry.")
            continue

        # In strict mode, verify the file's integrity before moving.
        if strict:
            try:
                if _sha256(dst) != rec["sha256"]:
                    raise ValueError(
                        f"Checksum mismatch for {dst}. The file may have been modified. Halting rollback."
                    )
            except (NotImplementedError, FileNotFoundError) as e:
                 raise ValueError(f"Could not verify checksum for {dst}: {e}")


        # If the original source path is now occupied, rename the existing file
        # to prevent data loss.
        if src.exists():
            trash_path = src.with_suffix(src.suffix + _TRASH_SUFFIX)
            print(f"Warning: Source path {src} is occupied. Moving existing file to {trash_path}")
            src.replace(trash_path)

        # Ensure the original parent directory exists before moving the file back.
        src.parent.mkdir(parents=True, exist_ok=True)
        shutil.move(dst, src)
        print(f"Rolled back: Moved {dst} -> {src}")

__all__ = ["rollback"]
